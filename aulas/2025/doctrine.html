<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Doctrine</title>

		<link rel="stylesheet" href="../../dist/reset.css">
		<link rel="stylesheet" href="../../dist/reveal.css">
		<link rel="stylesheet" href="../../dist/theme/white.css">

		<link rel="stylesheet" href="../../plugin/highlight/monokai.css">
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
					<h2>Introdução ao Doctrine ORM</h2>
					<p>Usando Doctrine em uma aplicação PHP pura</p>
				</section>

				<section data-background="#333">
					<p class="r-fit-text">DBAL / ORM</p>
				</section>

				<section>
					<h1>DBAL</h1>
					<hr>
					<p>Database Abstraction Layer</p>
					<ul>
						<li class="fragment">Serviços básicos: Insert, Select, Update, Delete</li>
						<li class="fragment">Transactions</li>
						<li class="fragment">É praticamente um PDO muito melhorado.</li>
					</ul>
				</section>

				<section>
					<h1>ORM</h1>
					<hr>
					<p>Object Relational Mapper</p>
					<ul>
						<li class="fragment">Mapeamento de Entidades</li>
						<li class="fragment">DQL</li>
						<li class="fragment">Chega de criar o banco de dados no PHPmyAdmin</li>
					</ul>
				</section>

				<section data-background-size="50%" data-background="https://media.slid.es/uploads/402795/images/2640393/vidadecao.gif"></section>

				<section>
					<h2>O que é o Doctrine?</h2>
					<ul>
						<li class="fragment">ORM (Object-Relational Mapper) para PHP</li>
						<li class="fragment">Permite mapear classes PHP para tabelas do banco</li>
						<li class="fragment">Popular no ecossistema Symfony, mas pode ser usado isoladamente</li>
					</ul>
				</section>

				<section>
					<h2>Instalação com Composer</h2>
					<pre><code class="hljs bash">composer require doctrine/orm</code></pre>
					<ul>
						<li class="fragment">Requer também `doctrine/annotations`, `symfony/cache`, `psr/cache`, etc.</li>
						<li class="fragment">Sugestão: usar Doctrine DBAL para controle de conexões</li>
					</ul>
				</section>

				<section>
					<h2>Configuração básica</h2>
					<pre><code class="hljs php">use Doctrine\ORM\Tools\Setup;
use Doctrine\ORM\EntityManager;

$config = Setup::createAttributeMetadataConfiguration([
  __DIR__ . "/src"
], true);

$conn = [
  'dbname' => 'meubanco',
  'user' => 'root',
  'password' => '',
  'host' => 'localhost',
  'driver' => 'pdo_mysql',
];

$entityManager = EntityManager::create($conn, $config);</code></pre>
				</section>

				<section>
					<h2>Entidades</h2>
					<pre><code class="hljs php">use Doctrine\ORM\Mapping as ORM;

#[ORM\Entity]
#[ORM\Table(name: "produtos")]
class Produto {
  #[ORM\Id]
  #[ORM\Column(type: "integer")]
  #[ORM\GeneratedValue]
  private int $id;

  #[ORM\Column(type: "string")]
  private string $nome;

  // getters e setters
}</code></pre>
					<ul>
						<li class="fragment">Attributes definem o mapeamento da classe</li>
						<li class="fragment">Cada entidade representa uma tabela</li>
					</ul>
				</section>

        <section>
					<h2>EntityManager/Connection</h2>
					<pre><code class="hljs php">
EntityManagerInterface $entityManager;
          </code></pre>
					<ul>
						<li class="fragment">usado para persist e remove</li>
						<li class="fragment">Representa a Conexão em si</li>
					</ul>
				</section>

				<section>
					<h2>Persistência de dados</h2>
					<pre><code class="hljs php">$produto = new Produto();
$produto->setNome("Café");

$entityManager->persist($produto);
$entityManager->flush();</code></pre>
					<ul>
						<li class="fragment">`persist` marca o objeto para inserção</li>
						<li class="fragment">`flush` executa no banco</li>
					</ul>
				</section>

        <section>
					<h2>Remoção de dados</h2>
					<pre><code class="hljs php">
$entityManager->remove($produto);
$entityManager->flush();</code></pre>
					<ul>
						<li class="fragment">`persist` marca o objeto para ser removido</li>
						<li class="fragment">`flush` executa no banco</li>
					</ul>
				</section>

        <section data-background="#333">
          <h1>Padrão Repository</h1>
        </section>

				<section>
					<pre><code class="hljs php">$repository = $entityManager->getRepository(Produto::class);
$produto = $repository->find(1);
$produtos = $repository->findAll();</code></pre>
					<ul>
						<li class="fragment">Buscas simples direto na tabela</li>
						<li class="fragment">Pode criar repositories customizados</li>
            <li class="fragment">Já traz os objetos hidratados</li>
					</ul>
				</section>

        <section>
					<pre>
<code class="hljs php">$repository = $entityManager->getRepository(Produto::class);
$produto = $repository->findOneBy([
  'id' => 2,
]); // Product
$produtos = $repo->findBy([
  'category' => 4,
]); // array (Product)
</code></pre>
				</section>

				<section style="display: none;">
					<h2>Migrations com Doctrine</h2>
					<ul>
						<li class="fragment">Permite versionar alterações no schema</li>
						<li class="fragment">Instalação: <code>composer require doctrine/migrations</code></li>
						<li class="fragment">Geração: <code>vendor/bin/doctrine-migrations diff</code></li>
						<li class="fragment">Execução: <code>vendor/bin/doctrine-migrations migrate</code></li>
					</ul>
				</section>

				<section>
					<h2>Relacionamentos</h2>
					<ul>
						<li class="fragment"><strong>OneToMany / ManyToOne:</strong> Uma categoria tem vários anuncios</li>
						<li class="fragment"><strong>OneToOne:</strong> Um anuncio tem um endereço</li>
						<li class="fragment"><strong>ManyToMany:</strong> Anuncios e Avaliações</li>
					</ul>
				</section>

				<section>
					<h2>Exemplo: OneToMany</h2>
					<pre><code class="hljs php">use Doctrine\ORM\Mapping as ORM;

#[ORM\Entity]
class Cliente {
  #[ORM\OneToMany(targetEntity: Pedido::class, mappedBy: "cliente")]
  private Collection $pedidos;
}

#[ORM\Entity]
class Pedido {
  #[ORM\ManyToOne(targetEntity: Cliente::class, inversedBy: "pedidos")]
  private Cliente $cliente;
}</code></pre>
				</section>

				<section>
					<h2>Exemplo: OneToOne</h2>
					<pre><code class="hljs php">use Doctrine\ORM\Mapping as ORM;

#[ORM\Entity]
class Usuario {
  #[ORM\OneToOne(targetEntity: Perfil::class)]
  #[ORM\JoinColumn(name: "perfil_id", referencedColumnName: "id")]
  private Perfil $perfil;
}

#[ORM\Entity]
class Perfil {
  // ...
}</code></pre>
				</section>

				<section>
					<h2>Exemplo: ManyToMany</h2>
					<pre><code class="hljs php">use Doctrine\ORM\Mapping as ORM;

#[ORM\Entity]
class Produto {
  #[ORM\ManyToMany(targetEntity: Categoria::class)]
  private Collection $categorias;
}

#[ORM\Entity]
class Categoria {
  #[ORM\ManyToMany(targetEntity: Produto::class, mappedBy: "categorias")]
  private Collection $produtos;
}</code></pre>
				</section>

				<section data-background="#333">
					<h1>EventListeners</h1>
				</section>

				<section>
					<h2>O que são os eventos?</h2>

					<p class="fragment">
						Praticamente "tudo" que acontece com uma entidade
					</p>
				</section>

				<section>
					<h2>Eventos mais comuns</h2>

					<ul>
						<li class="fragment">PostLoad</li>
						<li class="fragment">PrePersist</li>
						<li class="fragment">PostPersist</li>
						<li class="fragment">...Update</li>
						<li class="fragment">...Remove</li>
						<li class="fragment">
							<a href="https://www.doctrine-project.org/projects/doctrine-orm/en/3.1/reference/events.html#events-overview">Outros</a>
						</li>
					</ul>
				</section>

				<section data-background="#333">
					<h1>Abordagem LifeCycle</h1>
					<hr>
					<p class="fragment">
						Consiste em implementar disparos de eventos dentro da própria classe que representa a entidade
					</p>
				</section>

				<section>
					<img width="80%" src="img/doctrine-events/example_00.png" alt="">
				</section>


				<section>
					<p>A grande desvantagem aqui é que precisariamos sempre chamar o <br> <em>
						<code  class="hljs php">$this->updatedAt = new DateTime();</code>
					</em> <br> em todos os métodos set()</p>
				</section>

				<section data-background="#7f1734">
					Conseguimos resolver isso facilmente com o <strong>PreUpdate</strong>
				</section>

				<section>
					<img width="80%" src="img/doctrine-events/example_01.png" alt="">
				</section>

				<section data-background="#333">
					<h1>Abordagem EventListener</h1>
					<hr>
					<p class="fragment">
						Consiste em implementar um "ouvinte" de eventos, para escutar o que acontece em outras classes (tipo um Observer)
					</p>
				</section>


				<section>
					<img width="80%" src="img/doctrine-events/example_02.png" alt="">
				</section>


				<section>
					<img width="80%" src="img/doctrine-events/example_03.png" alt="">
				</section>

				<section>
					<h2>Dicas práticas</h2>
					<ul>
						<li class="fragment">Use namespaces e PSR-4 para organização</li>
						<li class="fragment">Utilize o CLI do Doctrine para debug</li>
						<li class="fragment">Prefira attributes ou XML/JSON conforme o contexto do projeto</li>
						<li class="fragment">Faça commit dos arquivos de migrations no Git</li>
					</ul>
				</section>

			</div>
		</div>

		<script src="../../dist/reveal.js"></script>
		<script src="../../plugin/notes/notes.js"></script>
		<script src="../../plugin/markdown/markdown.js"></script>
		<script src="../../plugin/highlight/highlight.js"></script>
		<script src="../../plugin/zoom/zoom.js"></script>
		<script src="https://cdn.jsdelivr.net/npm/reveal.js-mermaid-plugin@2.3.0/plugin/mermaid/mermaid.js"></script>
		<script>
			Reveal.initialize({
				hash: true,
				mermaid: {},
				plugins: [ RevealZoom, RevealMarkdown, RevealHighlight, RevealNotes, RevealMermaid ]
			});
		</script>
	</body>
</html>
